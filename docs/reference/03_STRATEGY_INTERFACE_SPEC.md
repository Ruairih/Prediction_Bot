# Strategy Interface Specification

## Overview

The Strategy Interface defines how trading strategies plug into the bot. Each strategy is self-contained and provides:
- Which markets to watch
- When to generate trading signals
- What parameters/filters to apply

The bot handles everything else (data, execution, monitoring).

---

## Core Concepts

### 1. Strategy Protocol

Every strategy must implement this interface:

```python
"""
Base strategy interface.

All strategies implement this protocol to plug into the trading bot.
"""
from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Protocol, runtime_checkable

from ..ingestion.types import MarketResponse, PriceUpdate, TradeResponse


class SignalAction(str, Enum):
    """What action the strategy wants to take."""
    BUY = "buy"
    SELL = "sell"
    WATCH = "watch"      # Add to watchlist for later
    IGNORE = "ignore"    # Skip this opportunity


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    The Core Engine receives these and routes to Execution.
    """
    action: SignalAction
    token_id: str
    condition_id: str

    # For BUY/SELL actions
    price: Optional[float] = None
    size: Optional[float] = None

    # Strategy metadata
    strategy_name: str = ""
    reason: str = ""
    confidence: Optional[float] = None  # 0-1 confidence score

    # Additional data for logging/analysis
    metadata: Dict[str, Any] = field(default_factory=dict)


@runtime_checkable
class Strategy(Protocol):
    """
    Protocol that all strategies must implement.

    Strategies are stateless decision makers. They receive market data
    and return signals. The bot handles execution, storage, etc.
    """

    @property
    def name(self) -> str:
        """Unique strategy identifier."""
        ...

    @property
    def version(self) -> str:
        """Strategy version (for tracking changes)."""
        ...

    def should_watch(self, market: MarketResponse) -> bool:
        """
        Should this strategy subscribe to this market?

        Called during watchlist computation. Return True to receive
        price updates for this market.

        Args:
            market: Market metadata from API

        Returns:
            True if strategy wants to watch this market
        """
        ...

    def on_price_update(
        self,
        update: PriceUpdate,
        context: "StrategyContext",
    ) -> Optional[Signal]:
        """
        Handle real-time price update from WebSocket.

        Called for every price update on watched markets.

        Args:
            update: Price update (NOTE: no trade size!)
            context: Access to market data, historical info

        Returns:
            Signal if strategy wants to act, None otherwise
        """
        ...

    def on_trade(
        self,
        trade: TradeResponse,
        context: "StrategyContext",
    ) -> Optional[Signal]:
        """
        Handle trade event.

        Called when a trade is detected (from REST API polling or WebSocket).
        Unlike price updates, trades include size.

        Args:
            trade: Trade data including size
            context: Access to market data, historical info

        Returns:
            Signal if strategy wants to act, None otherwise
        """
        ...

    def on_watchlist_check(
        self,
        token_id: str,
        context: "StrategyContext",
    ) -> Optional[Signal]:
        """
        Periodic re-evaluation of watchlisted items.

        Called by the watchlist re-scorer service.

        Args:
            token_id: Token on the watchlist
            context: Current market state

        Returns:
            Signal to promote/demote/ignore
        """
        ...


@dataclass
class StrategyContext:
    """
    Context provided to strategies for decision making.

    Strategies don't access databases directly - they use this
    context to get the data they need.
    """
    # Current market state
    token_id: str
    condition_id: str
    question: str
    current_price: float
    current_timestamp: int

    # Market metadata
    category: Optional[str] = None
    scheduled_end: Optional[str] = None
    is_resolved: bool = False

    # Historical data (lazy-loaded)
    _get_recent_trades: Optional[callable] = None
    _get_sibling_token: Optional[callable] = None
    _get_trigger_history: Optional[callable] = None

    def get_recent_trades(self, limit: int = 20) -> List[TradeResponse]:
        """Get recent trades for this token."""
        if self._get_recent_trades:
            return self._get_recent_trades(self.token_id, limit)
        return []

    def get_sibling_price(self) -> Optional[float]:
        """Get current price of sibling token (YES if this is NO, etc.)."""
        if self._get_sibling_token:
            sibling = self._get_sibling_token(self.token_id)
            if sibling:
                # Would need to fetch price - this is simplified
                return None
        return None

    def has_triggered_before(self, threshold: float) -> bool:
        """Check if this token/condition has triggered at threshold."""
        if self._get_trigger_history:
            return self._get_trigger_history(self.condition_id, threshold)
        return False

    def time_to_end_hours(self) -> Optional[float]:
        """Hours until scheduled end."""
        if not self.scheduled_end:
            return None
        from datetime import datetime, timezone
        try:
            end = datetime.fromisoformat(self.scheduled_end.replace("Z", "+00:00"))
            now = datetime.now(timezone.utc)
            return max(0, (end - now).total_seconds() / 3600)
        except:
            return None
```

### 2. Strategy Registry

Strategies are registered and discovered dynamically:

```python
"""
Strategy registry for dynamic strategy loading.
"""
from __future__ import annotations

import importlib
import logging
from typing import Dict, List, Optional, Type

from .base import Strategy

logger = logging.getLogger(__name__)


class StrategyRegistry:
    """
    Registry for strategy discovery and instantiation.

    Strategies can be:
    1. Registered programmatically
    2. Auto-discovered from the strategies/ directory
    3. Loaded from config
    """

    _strategies: Dict[str, Type[Strategy]] = {}
    _instances: Dict[str, Strategy] = {}

    @classmethod
    def register(cls, strategy_class: Type[Strategy]) -> Type[Strategy]:
        """
        Register a strategy class.

        Can be used as decorator:
            @StrategyRegistry.register
            class MyStrategy:
                ...
        """
        # Instantiate to get name
        instance = strategy_class()
        name = instance.name

        if name in cls._strategies:
            logger.warning(f"Overwriting existing strategy: {name}")

        cls._strategies[name] = strategy_class
        logger.info(f"Registered strategy: {name} v{instance.version}")

        return strategy_class

    @classmethod
    def get(cls, name: str) -> Optional[Strategy]:
        """Get strategy instance by name."""
        if name not in cls._instances:
            if name not in cls._strategies:
                return None
            cls._instances[name] = cls._strategies[name]()

        return cls._instances[name]

    @classmethod
    def get_all(cls) -> List[Strategy]:
        """Get all registered strategies."""
        return [cls.get(name) for name in cls._strategies]

    @classmethod
    def list_names(cls) -> List[str]:
        """List all registered strategy names."""
        return list(cls._strategies.keys())

    @classmethod
    def discover(cls, package: str = "polymarket_bot.strategies") -> int:
        """
        Auto-discover strategies in a package.

        Looks for modules with a `Strategy` class that implements
        the Strategy protocol.

        Returns:
            Number of strategies discovered
        """
        import pkgutil

        count = 0
        try:
            pkg = importlib.import_module(package)
            for _, module_name, _ in pkgutil.iter_modules(pkg.__path__):
                if module_name.startswith("_"):
                    continue

                try:
                    module = importlib.import_module(f"{package}.{module_name}")

                    # Look for Strategy subclasses
                    for attr_name in dir(module):
                        attr = getattr(module, attr_name)
                        if (isinstance(attr, type) and
                            issubclass(attr, Strategy) and
                            attr is not Strategy):
                            cls.register(attr)
                            count += 1

                except Exception as e:
                    logger.warning(f"Failed to load strategy module {module_name}: {e}")

        except Exception as e:
            logger.error(f"Strategy discovery failed: {e}")

        return count
```

---

## 3. Example Strategy: High Probability YES

This is the strategy from our backtesting - now as a pluggable module:

```python
"""
High Probability YES Strategy.

Buys prediction market favorites when they first cross a price threshold,
betting they will resolve to YES (100c).

Based on extensive backtesting (Dec 2025):
- Model score >= 0.97: 99.13% win rate
- With size filter >= 50: 99.20% win rate
- Break-even is 95.1% after 2% Polymarket fee

Key insight: First-hit triggers on high-confidence markets have edge.
"""
from __future__ import annotations

import logging
import math
import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

import joblib
import pandas as pd

from ..base import Signal, SignalAction, Strategy, StrategyContext, StrategyRegistry
from ...ingestion.types import MarketResponse, PriceUpdate, TradeResponse

logger = logging.getLogger(__name__)


@dataclass
class HighProbYesConfig:
    """Configuration for High Probability YES strategy."""
    # Thresholds
    watch_threshold: float = 0.95     # Watch markets at this price
    execute_threshold: float = 0.97   # Model score needed to execute
    watchlist_threshold: float = 0.90 # Add to watchlist at this score
    max_price: float = 0.95           # Never pay more than this

    # Trade size filter (CRITICAL for 99% win rate)
    min_trigger_size: float = 50.0    # Minimum trigger trade size

    # Time filters
    min_time_to_end_hours: float = 6.0    # Don't trade near expiry
    max_time_to_end_hours: float = 2160.0 # 90 days - capital efficiency

    # Position sizing
    default_position_size: float = 2.0  # Shares per trade

    # Model path
    model_path: Path = Path("models/guardrail_model.pkl")


@StrategyRegistry.register
class HighProbYesStrategy(Strategy):
    """
    High Probability YES Strategy implementation.

    Entry Criteria (all required):
    1. First trade >= 0.95 threshold
    2. Entry price <= 0.95 (never overpay)
    3. Model score >= 0.97
    4. Trigger trade size >= 50 shares (CRITICAL)
    5. Time to end >= 6 hours
    6. Not a weather market
    7. Not a sibling-dual-95 situation

    Exit:
    - Default: Hold to resolution
    - Optional: 99c profit target + 90c stop for >7d trades
    """

    def __init__(self, config: Optional[HighProbYesConfig] = None) -> None:
        self.config = config or HighProbYesConfig()
        self._model = None
        self._seen_triggers: set = set()  # In-memory dedup

    @property
    def name(self) -> str:
        return "high_prob_yes"

    @property
    def version(self) -> str:
        return "2.0.0"  # Dec 2025 validated version

    @property
    def model(self):
        """Lazy-load ML model."""
        if self._model is None and self.config.model_path.exists():
            self._model = joblib.load(self.config.model_path)
            logger.info(f"Loaded model from {self.config.model_path}")
        return self._model

    # ================================================================
    # Strategy Protocol Implementation
    # ================================================================

    def should_watch(self, market: MarketResponse) -> bool:
        """
        Watch markets that could potentially trigger.

        We watch markets below threshold to catch them as they approach.
        """
        # Don't watch resolved markets
        if market.closed or market.archived:
            return False

        # Don't watch weather markets (hard filter)
        if self._is_weather_market(market.question, market.category):
            return False

        # Would need current price to filter - for now, watch all active
        return True

    def on_price_update(
        self,
        update: PriceUpdate,
        context: StrategyContext,
    ) -> Optional[Signal]:
        """
        Handle real-time price update.

        NOTE: PriceUpdate does NOT include trade size!
        We can only do preliminary checks here, then need to
        fetch trade data for full evaluation.
        """
        price = float(update.price)

        # Quick rejection checks
        if price < self.config.watch_threshold:
            return None

        if price > self.config.max_price:
            return None

        # Check if already triggered (in-memory)
        trigger_key = f"{context.condition_id}:{self.config.watch_threshold}"
        if trigger_key in self._seen_triggers:
            return None

        # Check if previously triggered (from DB via context)
        if context.has_triggered_before(self.config.watch_threshold):
            self._seen_triggers.add(trigger_key)
            return None

        # This looks like a potential trigger!
        # But we need trade size for full evaluation.
        # Return WATCH signal to trigger trade data fetch.
        return Signal(
            action=SignalAction.WATCH,
            token_id=context.token_id,
            condition_id=context.condition_id,
            price=price,
            strategy_name=self.name,
            reason="price_trigger_needs_trade_data",
            metadata={"trigger_price": price},
        )

    def on_trade(
        self,
        trade: TradeResponse,
        context: StrategyContext,
    ) -> Optional[Signal]:
        """
        Handle trade event with full data including size.

        This is where the real decision happens.
        """
        price = trade.price
        size = trade.size

        # Price checks
        if price < self.config.watch_threshold:
            return None
        if price > self.config.max_price:
            return None

        # Deduplication
        trigger_key = f"{context.condition_id}:{self.config.watch_threshold}"
        if trigger_key in self._seen_triggers:
            return None
        if context.has_triggered_before(self.config.watch_threshold):
            self._seen_triggers.add(trigger_key)
            return None

        # Mark as triggered (prevents duplicates)
        self._seen_triggers.add(trigger_key)

        # ============================================================
        # HARD FILTERS (reject immediately)
        # ============================================================

        # 1. Weather market (7.13% loss rate)
        if self._is_weather_market(context.question, context.category):
            return self._reject_signal(context, "weather_market")

        # 2. Time to end too short (< 6h)
        time_to_end = context.time_to_end_hours()
        if time_to_end is not None:
            if time_to_end < self.config.min_time_to_end_hours:
                return self._reject_signal(context, f"time_too_short:{time_to_end:.1f}h")
            if time_to_end > self.config.max_time_to_end_hours:
                return self._reject_signal(context, f"time_too_long:{time_to_end:.0f}h")

        # 3. Trade size filter (CRITICAL for 99% win rate)
        if size < self.config.min_trigger_size:
            return self._reject_signal(
                context,
                f"size_too_small:{size:.0f}<{self.config.min_trigger_size:.0f}"
            )

        # ============================================================
        # MODEL SCORING
        # ============================================================

        features = self._compute_features(trade, context)
        if features is None:
            return self._reject_signal(context, "feature_computation_failed")

        score = self._score(features)
        if score is None:
            return self._reject_signal(context, "scoring_failed")

        # ============================================================
        # DECISION
        # ============================================================

        if score >= self.config.execute_threshold:
            # Execute immediately
            return Signal(
                action=SignalAction.BUY,
                token_id=context.token_id,
                condition_id=context.condition_id,
                price=price,
                size=self.config.default_position_size,
                strategy_name=self.name,
                reason=f"score={score:.4f}>=threshold",
                confidence=score,
                metadata={
                    "trigger_price": price,
                    "trigger_size": size,
                    "model_score": score,
                    "time_to_end_hours": time_to_end,
                },
            )

        elif score >= self.config.watchlist_threshold:
            # Add to watchlist for re-scoring
            return Signal(
                action=SignalAction.WATCH,
                token_id=context.token_id,
                condition_id=context.condition_id,
                price=price,
                strategy_name=self.name,
                reason=f"score={score:.4f}_watchlist",
                confidence=score,
                metadata={
                    "trigger_price": price,
                    "trigger_size": size,
                    "model_score": score,
                    "time_to_end_hours": time_to_end,
                },
            )

        else:
            # Score too low
            return self._reject_signal(context, f"score_too_low:{score:.4f}")

    def on_watchlist_check(
        self,
        token_id: str,
        context: StrategyContext,
    ) -> Optional[Signal]:
        """
        Re-evaluate watchlisted item.

        Called hourly by watchlist re-scorer.
        Score can improve as time_to_end decreases.
        """
        # Check if market resolved
        if context.is_resolved:
            return Signal(
                action=SignalAction.IGNORE,
                token_id=token_id,
                condition_id=context.condition_id,
                strategy_name=self.name,
                reason="market_resolved",
            )

        # Check time to end
        time_to_end = context.time_to_end_hours()
        if time_to_end is not None and time_to_end < self.config.min_time_to_end_hours:
            return Signal(
                action=SignalAction.IGNORE,
                token_id=token_id,
                condition_id=context.condition_id,
                strategy_name=self.name,
                reason=f"expired:{time_to_end:.1f}h",
            )

        # Re-compute score with current features
        # Need to get original trigger data from watchlist entry
        # This is simplified - would need actual implementation
        features = self._compute_features_for_rescore(context)
        if features is None:
            return None

        score = self._score(features)
        if score is None:
            return None

        if score >= self.config.execute_threshold:
            # Promote to execution!
            return Signal(
                action=SignalAction.BUY,
                token_id=token_id,
                condition_id=context.condition_id,
                price=context.current_price,
                size=self.config.default_position_size,
                strategy_name=self.name,
                reason=f"watchlist_promoted:score={score:.4f}",
                confidence=score,
            )

        # Keep watching
        return None

    # ================================================================
    # Internal Methods
    # ================================================================

    def _reject_signal(self, context: StrategyContext, reason: str) -> Signal:
        """Create rejection signal for logging."""
        return Signal(
            action=SignalAction.IGNORE,
            token_id=context.token_id,
            condition_id=context.condition_id,
            strategy_name=self.name,
            reason=reason,
        )

    def _is_weather_market(
        self,
        question: Optional[str],
        category: Optional[str],
    ) -> bool:
        """
        Detect weather markets.

        CRITICAL: Use word boundaries to avoid "rain" matching "rainbow".
        """
        text = f"{question or ''} {category or ''}".lower()

        weather_keywords = [
            "weather", "temperature", "rain", "snow", "hurricane",
            "storm", "°f", "°c", "fahrenheit", "celsius"
        ]

        for keyword in weather_keywords:
            # Word boundary matching
            if re.search(r'\b' + re.escape(keyword) + r'\b', text):
                return True

        return False

    def _compute_features(
        self,
        trade: TradeResponse,
        context: StrategyContext,
    ) -> Optional[dict]:
        """Compute features for model scoring."""
        try:
            time_to_end = context.time_to_end_hours() or 720.0

            return {
                "trigger_price": trade.price,
                "trigger_trade_size": trade.size,
                "log_trigger_trade_size": math.log1p(trade.size),
                "time_to_end_hours": time_to_end,
                "price_spread": 0.02,  # Default
                "is_crypto": 1 if self._has_keyword(context.question, ["crypto", "btc", "bitcoin"]) else 0,
                "is_politics": 1 if self._has_keyword(context.question, ["election", "trump", "biden"]) else 0,
                "is_sports": 1 if self._has_keyword(context.question, ["nfl", "nba", "mlb"]) else 0,
                "is_weather": 0,  # Already filtered
                "is_range": 0,
                "is_narrative": 1,
                "is_outcome_yes": 1,
                "is_outcome_no": 0,
                "is_outcome_up": 0,
                "is_outcome_down": 0,
                "is_outcome_over": 0,
                "is_outcome_under": 0,
            }
        except Exception as e:
            logger.warning(f"Feature computation failed: {e}")
            return None

    def _compute_features_for_rescore(self, context: StrategyContext) -> Optional[dict]:
        """Compute features for watchlist re-scoring."""
        # Simplified - would need original trigger data
        return self._compute_features(
            TradeResponse(
                asset=context.token_id,
                price=context.current_price,
                size=100,  # Default
                side="buy",
            ),
            context,
        )

    def _score(self, features: dict) -> Optional[float]:
        """Score features with ML model."""
        if self.model is None:
            logger.warning("Model not loaded, cannot score")
            return None

        try:
            df = pd.DataFrame([features])
            proba = self.model.predict_proba(df)[0, 1]
            return float(proba)
        except Exception as e:
            logger.warning(f"Scoring failed: {e}")
            return None

    def _has_keyword(self, text: Optional[str], keywords: List[str]) -> bool:
        """Check for keywords with word boundaries."""
        if not text:
            return False
        text_lower = text.lower()
        for kw in keywords:
            if re.search(r'\b' + re.escape(kw) + r'\b', text_lower):
                return True
        return False
```

### Strategy CLAUDE.md

```markdown
# Strategies Layer

## Purpose
Implement pluggable trading strategies that generate signals.

## Responsibilities
- Decide which markets to watch
- Generate BUY/SELL/WATCH signals based on market data
- Apply strategy-specific filters and scoring

## NOT Responsibilities
- Executing orders (Execution Layer)
- Storing data (Storage Layer)
- Fetching market data (Ingestion Layer)

## Key Files

| File | Purpose |
|------|---------|
| `base.py` | Strategy protocol, Signal type, StrategyContext |
| `registry.py` | Strategy discovery and registration |
| `high_prob_yes/` | Example: High Probability YES strategy |

## Creating a New Strategy

1. Create a new directory: `strategies/my_strategy/`
2. Implement the Strategy protocol
3. Register with `@StrategyRegistry.register`
4. Add CLAUDE.md for the strategy

```python
@StrategyRegistry.register
class MyStrategy(Strategy):
    @property
    def name(self) -> str:
        return "my_strategy"

    @property
    def version(self) -> str:
        return "1.0.0"

    def should_watch(self, market: MarketResponse) -> bool:
        # Your logic here
        ...

    def on_price_update(self, update: PriceUpdate, context: StrategyContext) -> Optional[Signal]:
        # Your logic here
        ...

    def on_trade(self, trade: TradeResponse, context: StrategyContext) -> Optional[Signal]:
        # Your logic here
        ...

    def on_watchlist_check(self, token_id: str, context: StrategyContext) -> Optional[Signal]:
        # Your logic here
        ...
```

## Built-in Strategy: high_prob_yes

Entry criteria:
- Price >= 0.95 (first hit)
- Model score >= 0.97
- Trigger size >= 50 shares
- Time to end >= 6 hours
- Not weather market
- Not sibling-dual-95

This achieves 99.2% win rate in backtesting.

## Critical Gotchas

### 1. WebSocket Has No Trade Size
`on_price_update()` receives PriceUpdate which has NO size field.
Return WATCH signal to trigger trade data fetch if needed.

### 2. Word Boundaries for Category Detection
Use `re.search(r'\b' + keyword + r'\b', text)` to avoid "rain" matching "rainbow".

### 3. Deduplication is Strategy's Responsibility
Track seen triggers in-memory AND check context for DB triggers.

### 4. StrategyContext is Read-Only
Don't modify context. Generate signals instead.
```

---

This spec defines how strategies plug in. The `high_prob_yes` strategy is a complete, production-ready example.

Ready for the Core Engine and Execution Layer specs?
